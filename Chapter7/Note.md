* 成员函数必须在类作用域中声明，定义可选在类内或类外，类内定义默认是`inline`的
* 每一个成员函数有一个名为`this`的隐含参数，this is a const pointer to the current object
* member function body前的const用于修饰`this`指针，表明`this`具有low-level const，即：a const pointer to const object，这样，就不能通过`this`指针修改对象状态
* 如果`this`不具有low-level const，那么`this`就无法绑定到一个const对象。也就无法在const对象上调用该成员函数，这实际上限制了成员函数的使用范围！
* const对象，或具有low-level const的引用或指针，只能调用const member function
* 类解析顺序，1）成员声明，包括数据成员和函数成员；2）成员函数体
* 成员函数体在成员声明之后解析，这是成员函数可以随意使用类中声明的成员（而不用在意顺序)的基础
* 对指针解引用得到的是引用，是一个左值，不是右值
* 与class相关的非成员函数，与对应的的class在同一个header中声明，但是在其他文件中定义
* `constructor`定义object如何初始化，在obj被创建时执行
* 对数据成员优先使用`in-class initializer`，如果不存在，则使用该类型的默认初始化，内置类型的默认初始化是未定义的。因此，应该总是为内置类型的数据成员提供`类内初始值`
* 什么时候需要 编译期合成构造函数？
> 1. 定义了其他构造函数。如果需要某种情况下控制如何初始化，那么所有情况下都需要
> 2. 具有指针和引用数据成员的类
> 3. 类类型的数据成员没有默认构造函数，当前类的默认构造函数无法初始化那种缺少默认构造函数的数据成员！
* 如果类中默认构造函数的声明中包含了`=default`，那么该默认构造函数的是隐式`inline`的
* 构造器的初始值列表对数据成员执行的是直接初始化（效率更高），在构造器中对数据成员赋值是复制初始化
* 初始化列表中没有涉及的数据成员其初始化行为与默认构造函数初始化该数据成员的行为相同
* 初始化顺序不依赖于初始化列表中的先后顺序，而依赖于在类作用域中声明的先后顺序
* 如果为数据成员提供了`in-class initializer`，构造函数就不应该再次覆盖它
* public在外部可见，用于修饰类的接口；private只在当前类作用域中可见，用于实现`封装`具体实现
* `class`和`struct`唯一的区别就是默认访问级别不同，`class-private`、`struct-public`
* 如果打算将数据成员全部为public，那么使用struct；否则使用class
* 类中可以声明`data/function/type member`
* 与一般`class member`不同，type member 必须在使用前声明
* inline声明既可以在类内声明时出现，也可以在类外定义时出现
* inline函数一般选择在包含类声明的header中**定义**
* 成员函数也可以重载，实现重载的规则以及函数匹配过程与一般函数相同
* `mutable`修饰的数据成员，即使在const memeber function也可以被修改
* `in-class`初始化值既可以是直接初始化的形式，也可以是赋值初始化的形式
* const memver function只能返回reference to const（如果需要返回引用）
* 将接口公用的代码段使用private封装起来
* 即使两个类除type name外完全相同，他们的对象也不能相互赋值，他们是不同类型的对象！
* 类的声明和定义可以分离，已声明的类只能用于创建reference/pointer/parameter，不能创建其对象！只有在定义之后才能创建对象！
* 一个类不能拥有自身类型的对象，因为定义未完成的类是不完整的，数据成员可以“pointer/reference to the current class type”
* `friend`不具有传递性！
* `frined`声明甚至可以出现在实际声明之前，只影响对类的数据成员的访问，除此之外，没有其他作用！
* 类中成员的声明解析发生在函数定义解析之前！
* 不应该使成员函数形参名与数据成员相同！即使这样做不会引发错误！如果真的这样做，使用`ClassName::mem`和`::mem`可以分别访问到memeber和类外定义的对象
* 初始化列表执行的初始化在构造函数体执行之前
* 必须使用初始化列表的理由:
> * const数据成员只能使用初始化，不能被赋值
> * 引用类型的数据成员，必须在初始化时绑定对象
> * 缺少默认构造函数的类成员
> * （非必须）初始化的效率 比初始化后再赋值 **高**
* 初始化列表无法决定初始化顺序，初始化顺序与成员在类中的声明顺序一致
* 应该避免使用一个数据成员去初始化另一个数据成员！
* 新标准引入委托构造函数，允许将部分初始化的工作委托给其他构造函数（注：被委托的构造函数的函数体将被执行！）
```c++
Delegating(params): Delegated(partial params)
```
* 转换构造函数特指直接收一个参数的构造函数，这种构造函数定义了一种隐式转换规则（注意这种转换只能发生一次！）
* 使用`explict`关键字修饰单参数构造函数，可以避免通过单参构造函数做隐式类型转换，该关键字只能在类中声明时使用！
* 使用`static_cast`可以显式调用单参数构造函数创建临时对象
* 与类相关联（而不是与对象）的成员应该声明为static的
* static成员函数没有隐含的`this`指针，因此函数不能是const的，且在函数体中不能访问普通的成员变量
* 普通成员函数中可以使用static数据成员而不用任何限定，类外使用static数据成员，既可以通过`ClassName::static-member`，也可以通过任何一个对象来访问！
* static成员在类外定义时，不需要加`static`限定符
* static数据成员不能使用构造函数初始化，一般我们也不在类内初始化，而是在类外，以赋值的方式初始化
* static数据成员可以是当前类的对象！还可以做形参的默认值！
* static const data member才能在类内初始化，普通static data member只能在类外初始化!
