* C++是静态类型语言，类型检查在编译时完成
* C++中，赋值和初始化是完全不同的操作，初始化是在分配存储空间是就指定了值；赋值会
擦除对象存储空间的旧值，并以新值覆盖
* 使用列表初始化不允许出现隐式类型转换
* 变量名命名规则：保留字不可、库中定义的（双下划线开头，单下划线+大写字母）不可
* 命名规范最重要的是保持一致性
* 变量的可见性从声明处开始，直到所在作用域结束都是可见的
* 作用域可以嵌套，内层作用域可以访问外层作用域中声明的变量，也可以定义同名的变量来覆盖外层作用域中的同名变量。
* 访问被覆盖的全局变量，需要使用域操作符`::`，如`::globalVar`，因为全局作用域没有名字
* 函数也是一种变量，具有全局作用域。
* 变量声明由基础类型 + 说明符构成，基本类型的声明中，说明符只包含变量名，指针和引用声明中还包含`*`和`&`
* 引用类型“引用”另一种类型，引用类型的变量是变量的别名，必须在声明时初始化（绑定某个变量），左值引用一旦绑定，便不可再绑定其他变量！
* 指针变量是实际的对象，无需在定义时初始化，可以指向不同的对象，可以被赋值和复制
* 指针的类型必须与所指向对象的类型完全匹配，指针的类型用于推断所指向点处存储对象的类型。
* lvalue引用只能与对象绑定，不可绑定字面量或者表达式，且引用的类型与对象类型要完全匹配！
* 由于引用类型的变量不是实际的对象，因此无法定义“引用的引用”！
* 由于要支持分离式编译，因此需要区分声明和定义，声明是为了获得可见性，定义却会将变量名和内存实体关联起来
* 声明不分配空间，定义分配内存
* 变量只会被定义一次，但是可以声明多次，任何一次定义都是一次声明
* 使用`extern`关键字可以实现单独的声明，不应该在`extern`中使用初始化列表，但是可以赋值！
* const 修饰的声明为常量定义，必须进行初始化，如果使用字面量初始化，则初始化发生在编译时，如果使用表达式初始化，则初始化发生在运行时
* decltype(*p)中对指针p解引用，得到的类型是引用类型，而不是简单的基本类型！ 
* decltype((i))结果为引用类型，(i)被当作表达式；decltype(i) 结果为简单类型
* 类作用域中定义的标识符必须是唯一，但是可以覆盖在类作用域外定义的标识符
* 标记类作用域结束的花括号后必须有`;`，因为在花括号和分号之间可以定义类类型的变量。
* 新标准中，可以为成员变量提供`in-class`初始值，没有类内初始值的成员将会有默认初始化