* 当使用现有容器去初始化新容器是，容器类型和元素类型完全相同！
* 使用迭代器指定的范围初始化时，只需要元素类型匹配（相同或者可转换）
* 在顺序容器（除library array）上执行`swap`，并不会真正交换内容，可保证在常量时间完成！
* 除`string`上的swap，其他顺序容器swap不会导致迭代器失效
* 在容器上执行任何插入和删除操作都可能导致 指针、引用或迭代器失效
* 插入操作可能导致可随机访问的容器空间再分配
* 存在插入/删除操作的循环，一定存在失效问题，每次插入/删除操作之后应该刷新迭代器
* 避免存储end的结果，end应该实时计算
* 只有当reserve要求的元素数超出现有容量，才会进行重新分配空间的操作
* reserve要求的元素数少于容量，不会释放已有空间；shrink_to_fit才可能会归还空间（依赖于具体实现）
* 空容器是不分配空间的，其capacity为0
* STL vector的capacity的增长策略是，每次增加一倍；空容器大小为0，添加一个元素增长为1
* 适配器的机制是：使一种东西表现得像另一种东西
* 容器适配器的第二个泛型参数可以用于指定底层容器的类型
* 默认情况下，queue底层使用deque，priority_queue使用vector