* 使用动态内存创建一个int对象，使用42直接进行初始化，同样的方式创建另一个动态int对象，使用100直接初始化
* 将指针q赋值给指针r，r中记录的地址和q中记录的地址相同，因此r和q指向同一个int对象（100）
* 由于值为42的int对象的地址被覆盖，因此我们丢失了那个对象的指针，由于没有任何一个指针指向那个对象，因此无法使用delete释放该对象所占用的动态内存，发生了内存泄漏！
* q2和r2分别是指向值为42和100的动态int对象的智能指针，由于他们分别是唯一指向各自内存的共享指针，因此所指向对象的引用计数都是1
* 将q2赋值给r2，由于r2由原来指向42改为指向100，因此原来42的引用计数-1，变为0，值为42的对象被释放，100的引用计数+1，变为2。赋值完成后，q2和r2都指向值为100的动态int对象
* 可以使用内置指针直接初始化shared_ptr，该构造函数是explict的
* 避免混用智能指针和内置指针，一旦使用内置指针初始化共享指针，就表示所指向内存的责任转交给共享指针，不应该再通过内置指针访问动态对象！
