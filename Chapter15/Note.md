* Object-Oriented基于三个概念：数据抽象、继承和动态绑定
* 只需要在声明时使用`virtual`，定义时不需要
* base class中声明为`virtual`的成员函数在派生类中是隐含`implict`的
* public继承也称为接口继承
* 新标准允许子类在override继承的virtual function时增加`override`关键字表明这是一个重写的函数
* 里氏替换原则：在使用基类的地方都可以使用子类
* 每个类的构造函数只能控制当前类的对象如何构造，对于子类，需要将部分工作委托给基类的构造器
* 继承声明与类定义在一起，而不是与类声明在一起
* 将类声明为`final`表明类不能被继承
* 使用override声明能够帮助在编译时就检查是否成功override一个基类的版本
* 一个变量的静态类型可能与它的动态类型不符合
* 普通成员函数如果不会被使用，甚至可以不定义；但是虚函数无论是否使用，都必须提供定义，否则类无法实例化
* 与继承相关的几个事实：
    1. 隐式类型转换只适用于指针（包括智能指针）和引用
    2. 基类不能隐式转为派生类
    3. 根据继承方式(public/protected/private)的不同，向上转型可能无法访问基类成员!
* 通过对象调用虚函数，绑定发生在编译时；通过指针或引用调用虚函数，发生在运行时

|调用方式\virtual?|是|否|
|---|---|---|
|对象|编译时|编译时|
|基类引用/指针|运行时|编译时|

* override virtual函数时，参数类型必须完全一致，返回类型可以有继承关系（Java里称为协变返回类型）
* final修饰的member function不能被override
* 如果virtual function有默认值，override版本使用的是基类版本的默认值